# ********************************************
# (For Python3.8)
# ＜Tech計算＞
#    ＺｉｇＺａｇ(ジグザグ)
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def ZigZag(Sdt:list,  Width:int=12) -> list:
    ''' ≪ＺｉｇＺａｇ≫
          【仮引数】Sdt   : 入力データ列 (リスト型)
                    NN    : 検出区間長 (山-山 or 谷-谷 の間隔)
          【戻り値】座標(x,y,Sg)のデータ列  (リスト型)
                    [Sg=True(山),False(谷)]
    '''
    # --------------------------------------------------------------
    # ■注意■ データ不足や範囲外 などの想定外なエラー対処は
    #          一切 考慮していない
    # --------------------------------------------------------------
    # ■ コメント ■
    #       戻り値は 視認性を優先して 座標(x,y)の形式にしている。
    #       MplFinance にて このまま直接プロットができないので、
    #       データ形式を変換する作業は必要ではある。
    # --------------------------------------------------------------
    # ■ 以下は [検討中] の仮引数 ■
    #       Keepth ："山-谷"間隔の最小値
    #       Depth  ：頂点判定の閾値 (上昇/下降の転換とする閾値 [許容変動幅])
    # --------------------------------------------------------------

    # --- ZigZagの計算 ---

    rlt = []                                    # リスト型の初期化
    HiCnt = [0] * len(Sdt)                      # (Max/Min)検知カウンター
    LwCnt = [0] * len(Sdt)                      # [len(Sdt)個の領域を確保]
    # --------------------------------------------------------------
    # ＜Memo＞  リスト型 などでは、リングバッファ的な使い方ができる
    #           例えば、最後の要素を取得するなら rlt[-1] のIndex指定
    #           で可能である
    # --------------------------------------------------------------

    # --- まず、頂点(Max/Min)の検知カウント処理 ---

    for kk in range(len(Sdt)):                  # 範囲 kk=[0, len(Sdt)-1]

        EPos = kk + Width                       # [EPos=kk+Width] 窓区間(Width) で頂点を検索する
        if(EPos > len(Sdt)):                    # [EPos>len(Sdt)] 残データのフラッシュ的にて検索する場合
            EPos = len(Sdt)                     #                 (最後尾なので区間幅が縮小される)

        nn = IndexOfHighest(Sdt, kk, EPos)      # 最大値とするPos位置を取得
        HiCnt[nn] = HiCnt[nn] + 1               # 検知カウントUp
        nn = IndexOfLowest(Sdt,  kk, EPos)      # 最小値とするPos位置を取得
        LwCnt[nn] = LwCnt[nn] + 1               # 検知カウントUp


    # --- 頂点情報へ変換と検知補正の処理 ---

    for kk in range(len(Sdt)):                                      # 範囲 kk=[0, len(Sdt)-1]

        if((HiCnt[kk] == Width) and (LwCnt[kk] == 0)):              # === "山"頂点の処理 ===

            if(len(rlt) == 0):                                      # ＜初期登録＞
                rlt.append({"x":kk, "y":Sdt[kk], "Sg":True})        # 辞書型にパックしてリストへ追加

            elif(rlt[-1]["Sg"]):                                    # ＜直近が"山"の場合＞
                if(rlt[-1]["y"] < Sdt[kk]):                         # 頂点"山"が更新しているならば
                    rlt[-1] = {"x":kk, "y":Sdt[kk], "Sg":True}      # 情報を上書き

            elif(not rlt[-1]["Sg"]):                                # ＜直近が"谷"の場合＞
                if(rlt[-1]["y"] > Sdt[kk]):                         # 直近"谷"よりも小さい逆転状態ならば
                    rlt.pop()                                       # 直近"谷"を取消し(削除)
                else:                                               # そうでなければ
                    rlt.append({"x":kk, "y":Sdt[kk], "Sg":True})    # ノーマルな "谷→山" として登録
            # -------------------------------------------------------------------
            # ＜Memo＞ popメソッドで引数の指定をしなければ 最後の要素が削除される。
            #          削除できる要素は１つのみ。 del文を使うと複数個の要素を
            #          削除できる。 (スライス指定が可能)
            # -------------------------------------------------------------------

        elif((HiCnt[kk] == 0) and (LwCnt[kk] == Width)):            # === "谷"頂点の処理 ===

            if(len(rlt) == 0):                                      # ＜初期登録＞
                rlt.append({"x":kk, "y":Sdt[kk], "Sg":False})       # 辞書型にパックしてリストへ追加

            elif(not rlt[-1]["Sg"]):                                # ＜直近が"谷"の場合＞
                if(rlt[-1]["y"] > Sdt[kk]):                         # 頂点"谷"が更新しているならば
                    rlt[-1] = {"x":kk, "y":Sdt[kk], "Sg":False}     # 情報を上書き

            elif(rlt[-1]["Sg"]):                                    # ＜直近が"山"の場合＞
                if(rlt[-1]["y"] < Sdt[kk]):                         # 直近"山"よりも大きい逆転状態ならば
                    rlt.pop()                                       # 直近"山"を取消し(削除)
                else:                                               # そうでなければ
                    rlt.append({"x":kk, "y":Sdt[kk], "Sg":False})   # ノーマルな "山→谷" として登録

    return rlt      # 戻り値のセット
    # -------------------------------------------------------------------
    # [補正１] 上昇トレンドでの微妙な押し目(期間が短くて浅い下落) にて、
    #          押し目のMin値[谷]を検出しても「直前の"山"頂点」は検出できない場合
    #          があり、結果、-> 谷 -> (未検知) -> [谷] -> 山 ->  の状態になる
    #          ■[補正] ⇒「現在」の[谷] をスキップ
    #                      実際には、"谷->谷"検知の「上昇状態」ならば "谷"をスキップ(何もしない)
    #
    # [補正２] 下降トレンドでの微妙な戻り(期間が短い急落での戻り) にて
    #          下落のMin値[谷]を検出しても「直後の"山"頂点」は検出できない場合
    #          があり、結果、-> 山 -> [谷] -> (未検出) -> 谷 ->  の状態になる
    #          ■[補正] ⇒「直前」の[谷]を削除して、「現在」の[谷]を登録
    #                      実際には、"谷->谷"検知で「下降状態」ならば "谷"を再登録(上書き)
    #
    # [補正３] 収束相場から抵抗線突破にて、検出した"山/谷"頂点の関係が、一部の未検知により
    #            "山"＜"谷" の逆転現象になる
    #          ■[補正] ⇒ 逆転となる"山/谷"双方の頂点をスキップ("直近"の登録済は削除)する
    #
    # [補正予定] "山-谷"間隔が短い場合の補正  [２つ山の高低で場合分け]   (★検討中★)
    #          ■[補正] a) "山-谷" ＜ "次の山"  ならば "山-谷"をスキップ
    #                   b) "山-谷" ＞ "次の山"  ならば "谷-次の山"をスキップ
    # -------------------------------------------------------------------


import sys                  # Floatの最大値/最小値

# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    指定範囲の最大値とするIndex番号を取得する
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def IndexOfHighest(Sdt:list, RngStart:int, RngEnd:int) -> int:
    ''' ≪ZigZag用の関数≫
          【仮引数】Sdt()    ：対象データの配列  (Double型)
                    RngStart ：開始のIndex番号
                    RngEnd   ：終了のIndex番号＋１ ("+1"はPythonの慣例に従うもの)
          【戻り値】Return   ：最大値とするIndex番号
    '''
    # -----------------------------------------------------------
    # ＜Note＞ 同じ機能を実現するのに、リストに対して max関数と
    #          indexメソッドを組み合わせれば可能だが、
    #          forループ処理した方が、断然 速いと考える
    # -----------------------------------------------------------

    Pos  = -1
    MaxV = -sys.float_info.max              # 負の最大値  (C# の Double.MinValue相当)
    # -----------------------------------------------------------------------
    # sys.float_info.min は "0"に最も近い 正の値 (2.2250738585072014e-308)
    # -----------------------------------------------------------------------

    # --- 最大値とするIndexを検索 ---
    for kk in range(RngStart, RngEnd):      #  範囲 kk=[Start, End-1]

        if(Sdt[kk] > MaxV):
            MaxV = Sdt[kk]
            Pos  = kk

    return Pos

# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    指定範囲の最小値とするIndex番号を取得する
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def IndexOfLowest(Sdt:list, RngStart:int, RngEnd:int) -> int:
    ''' ≪ZigZag用の関数≫
          【仮引数】Sdt()    ：対象データの配列
                    RngStart ：開始のIndex番号
                    RngEnd   ：終了のIndex番号＋１ ("+1"はPythonの慣例に従うもの)
          【戻り値】Return   ：最小値とするIndex番号
    '''
    # -----------------------------------------------------------
    # ＜Note＞ 同じ機能を実現するのに、リストに対して min関数と
    #          indexメソッドを組み合わせれば可能だが、
    #          forループ処理した方が、断然 速いと考える
    # -----------------------------------------------------------

    Pos  = -1
    MinV = sys.float_info.max               # 正の最大値  (C# の Double.MaxValue相当)

    # --- 最小値とするIndexを検索 ---
    for kk in range(RngStart, RngEnd):      #  範囲 kk=[Start, End-1]

        if(Sdt[kk] < MinV):
            MinV = Sdt[kk]
            Pos  = kk

    return Pos

# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    座標(x,y)形式 －＞ プロット形式 へ変換
#
# [更新履歴]
#   2022/05/26 V1.00 新規作成
# ********************************************
def toPlotDataForZigZag(Sdt:list) -> list:
    ''' ≪ZigZag用のデータ変換≫
          【仮引数】Sdt  : 座標(x,y)形式のデータ列
          【戻り値】MpfFinanceでのプロット用データ列
                    (Xdata列, Ydata列)
    '''
    Xdt:float = [0.0] * len(Sdt)
    Ydt:float = [0.0] * len(Sdt)

    for kk in range(len(Sdt)):
        Xdt[kk] = float(Sdt[kk]["x"])
        Ydt[kk] = Sdt[kk]["y"]

    return (Xdt, Ydt)

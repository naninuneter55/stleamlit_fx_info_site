import sys                  # Floatの最大値/最小値

# ********************************************
# (For Python3.8)
# ＜Tech計算＞
#    ＺｉｇＺａｇ(ジグザグ)
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def zigzag(std,  width=12):
    ''' ≪ＺｉｇＺａｇ≫
          【仮引数】std   : 入力データ列 (リスト型)
                    NN    : 検出区間長 (山-山 or 谷-谷 の間隔)
          【戻り値】座標(x,y,Sg)のデータ列  (リスト型)
                    [Sg=True(山),False(谷)]
    '''
    # --------------------------------------------------------------
    # ■注意■ データ不足や範囲外 などの想定外なエラー対処は
    #          一切 考慮していない
    # --------------------------------------------------------------
    # ■ コメント ■
    #       戻り値は 視認性を優先して 座標(x,y)の形式にしている。
    #       MplFinance にて このまま直接プロットができないので、
    #       データ形式を変換する作業は必要ではある。
    # --------------------------------------------------------------
    # ■ 以下は [検討中] の仮引数 ■
    #       Keepth ："山-谷"間隔の最小値
    #       Depth  ：頂点判定の閾値 (上昇/下降の転換とする閾値 [許容変動幅])
    # --------------------------------------------------------------

    # --- ZigZagの計算 ---

    rlt = []                                    # リスト型の初期化
    hi_cnt = [0] * len(std)                      # (Max/Min)検知カウンター
    lw_cnt = [0] * len(std)                      # [len(std)個の領域を確保]
    # --------------------------------------------------------------
    # ＜Memo＞  リスト型 などでは、リングバッファ的な使い方ができる
    #           例えば、最後の要素を取得するなら rlt[-1] のIndex指定
    #           で可能である
    # --------------------------------------------------------------

    # --- まず、頂点(Max/Min)の検知カウント処理 ---

    for kk in range(len(std)):                  # 範囲 kk=[0, len(std)-1]

        EPos = kk + width                       # [EPos=kk+width] 窓区間(width) で頂点を検索する
        if(EPos > len(std)):                    # [EPos>len(std)] 残データのフラッシュ的にて検索する場合
            EPos = len(std)                     #                 (最後尾なので区間幅が縮小される)

        nn = IndexOfHighest(std, kk, EPos)      # 最大値とするPos位置を取得
        hi_cnt[nn] = hi_cnt[nn] + 1               # 検知カウントUp
        nn = IndexOfLowest(std,  kk, EPos)      # 最小値とするPos位置を取得
        lw_cnt[nn] = lw_cnt[nn] + 1               # 検知カウントUp

    print(hi_cnt, len(hi_cnt))
    print(lw_cnt, len(lw_cnt))

    # --- 頂点情報へ変換と検知補正の処理 ---

    for kk in range(len(std)):                                      # 範囲 kk=[0, len(std)-1]

        if((hi_cnt[kk] == width) and (lw_cnt[kk] == 0)):              # === "山"頂点の処理 ===

            if(len(rlt) == 0):                                      # ＜初期登録＞
                rlt.append({"x":kk, "y":std[kk], "Sg":True})        # 辞書型にパックしてリストへ追加

            elif(rlt[-1]["Sg"]):                                    # ＜直近が"山"の場合＞
                if(rlt[-1]["y"] < std[kk]):                         # 頂点"山"が更新しているならば
                    rlt[-1] = {"x":kk, "y":std[kk], "Sg":True}      # 情報を上書き

            elif(not rlt[-1]["Sg"]):                                # ＜直近が"谷"の場合＞
                if(rlt[-1]["y"] > std[kk]):                         # 直近"谷"よりも小さい逆転状態ならば
                    rlt.pop()                                       # 直近"谷"を取消し(削除)
                else:                                               # そうでなければ
                    rlt.append({"x":kk, "y":std[kk], "Sg":True})    # ノーマルな "谷→山" として登録
            # -------------------------------------------------------------------
            # ＜Memo＞ popメソッドで引数の指定をしなければ 最後の要素が削除される。
            #          削除できる要素は１つのみ。 del文を使うと複数個の要素を
            #          削除できる。 (スライス指定が可能)
            # -------------------------------------------------------------------

        elif((hi_cnt[kk] == 0) and (lw_cnt[kk] == width)):            # === "谷"頂点の処理 ===

            if(len(rlt) == 0):                                      # ＜初期登録＞
                rlt.append({"x":kk, "y":std[kk], "Sg":False})       # 辞書型にパックしてリストへ追加

            elif(not rlt[-1]["Sg"]):                                # ＜直近が"谷"の場合＞
                if(rlt[-1]["y"] > std[kk]):                         # 頂点"谷"が更新しているならば
                    rlt[-1] = {"x":kk, "y":std[kk], "Sg":False}     # 情報を上書き

            elif(rlt[-1]["Sg"]):                                    # ＜直近が"山"の場合＞
                if(rlt[-1]["y"] < std[kk]):                         # 直近"山"よりも大きい逆転状態ならば
                    rlt.pop()                                       # 直近"山"を取消し(削除)
                else:                                               # そうでなければ
                    rlt.append({"x":kk, "y":std[kk], "Sg":False})   # ノーマルな "山→谷" として登録

    return rlt      # 戻り値のセット
    # -------------------------------------------------------------------
    # [補正１] 上昇トレンドでの微妙な押し目(期間が短くて浅い下落) にて、
    #          押し目のMin値[谷]を検出しても「直前の"山"頂点」は検出できない場合
    #          があり、結果、-> 谷 -> (未検知) -> [谷] -> 山 ->  の状態になる
    #          ■[補正] ⇒「現在」の[谷] をスキップ
    #                      実際には、"谷->谷"検知の「上昇状態」ならば "谷"をスキップ(何もしない)
    #
    # [補正２] 下降トレンドでの微妙な戻り(期間が短い急落での戻り) にて
    #          下落のMin値[谷]を検出しても「直後の"山"頂点」は検出できない場合
    #          があり、結果、-> 山 -> [谷] -> (未検出) -> 谷 ->  の状態になる
    #          ■[補正] ⇒「直前」の[谷]を削除して、「現在」の[谷]を登録
    #                      実際には、"谷->谷"検知で「下降状態」ならば "谷"を再登録(上書き)
    #
    # [補正３] 収束相場から抵抗線突破にて、検出した"山/谷"頂点の関係が、一部の未検知により
    #            "山"＜"谷" の逆転現象になる
    #          ■[補正] ⇒ 逆転となる"山/谷"双方の頂点をスキップ("直近"の登録済は削除)する
    #
    # [補正予定] "山-谷"間隔が短い場合の補正  [２つ山の高低で場合分け]   (★検討中★)
    #          ■[補正] a) "山-谷" ＜ "次の山"  ならば "山-谷"をスキップ
    #                   b) "山-谷" ＞ "次の山"  ならば "谷-次の山"をスキップ
    # -------------------------------------------------------------------



# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    指定範囲の最大値とするIndex番号を取得する
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def IndexOfHighest(std, RngStart, RngEnd):
    ''' ≪ZigZag用の関数≫
          【仮引数】std()    ：対象データの配列  (Double型)
                    RngStart ：開始のIndex番号
                    RngEnd   ：終了のIndex番号＋１ ("+1"はPythonの慣例に従うもの)
          【戻り値】Return   ：最大値とするIndex番号
    '''
    # -----------------------------------------------------------
    # ＜Note＞ 同じ機能を実現するのに、リストに対して max関数と
    #          indexメソッドを組み合わせれば可能だが、
    #          forループ処理した方が、断然 速いと考える
    # -----------------------------------------------------------

    Pos  = -1
    MaxV = -sys.float_info.max              # 負の最大値  (C# の Double.MinValue相当)
    # -----------------------------------------------------------------------
    # sys.float_info.min は "0"に最も近い 正の値 (2.2250738585072014e-308)
    # -----------------------------------------------------------------------

    # --- 最大値とするIndexを検索 ---
    for kk in range(RngStart, RngEnd):      #  範囲 kk=[Start, End-1]

        if(std[kk] > MaxV):
            MaxV = std[kk]
            Pos  = kk

    return Pos

# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    指定範囲の最小値とするIndex番号を取得する
#
# [更新履歴]
#   2022/05/25 V1.00 新規作成 [C# から Python へ移植]
# ********************************************
def IndexOfLowest(std:list, RngStart:int, RngEnd:int) -> int:
    ''' ≪ZigZag用の関数≫
          【仮引数】std()    ：対象データの配列
                    RngStart ：開始のIndex番号
                    RngEnd   ：終了のIndex番号＋１ ("+1"はPythonの慣例に従うもの)
          【戻り値】Return   ：最小値とするIndex番号
    '''
    # -----------------------------------------------------------
    # ＜Note＞ 同じ機能を実現するのに、リストに対して min関数と
    #          indexメソッドを組み合わせれば可能だが、
    #          forループ処理した方が、断然 速いと考える
    # -----------------------------------------------------------

    Pos  = -1
    MinV = sys.float_info.max               # 正の最大値  (C# の Double.MaxValue相当)

    # --- 最小値とするIndexを検索 ---
    for kk in range(RngStart, RngEnd):      #  範囲 kk=[Start, End-1]

        if(std[kk] < MinV):
            MinV = std[kk]
            Pos  = kk

    return Pos

# ********************************************
# (For Python3.8)
# ＜Tech計算：ZigZag＞
#    座標(x,y)形式 －＞ プロット形式 へ変換
#
# [更新履歴]
#   2022/05/26 V1.00 新規作成
# ********************************************
def toPlotDataForZigZag(std:list) -> list:
    ''' ≪ZigZag用のデータ変換≫
          【仮引数】std  : 座標(x,y)形式のデータ列
          【戻り値】MpfFinanceでのプロット用データ列
                    (Xdata列, Ydata列)
    '''
    Xdt:float = [0.0] * len(std)
    Ydt:float = [0.0] * len(std)

    for kk in range(len(std)):
        Xdt[kk] = float(std[kk]["x"])
        Ydt[kk] = std[kk]["y"]

    return (Xdt, Ydt)
